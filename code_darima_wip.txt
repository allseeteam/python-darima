SUMMARIZATION:
 Functions -> features
 Plotting: autoplot, ACF, PACF, gg_tsdisplay, gg_tsresiduals
 Tests: ljung_box, unitroot_kpss, unitroot_ndiffs
 Modelling: ARIMA, forecast, model, glance, augment
 Calculations: difference
 

Differences

difference <- function(x, lag = 1, differences = 1, default = NA,
                       order_by = NULL) {
  if (lag < 1 || differences < 1) {
    abort("`lag` and `differences` must be positive integers.")
  }
  if (is_null(order_by)) {
    diff_impl(x, lag = lag, differences = differences, default = default)
  } else {
    with_order(order_by, diff_impl, x,
      lag = lag, differences = differences, default = default
    )
  }
}

diff_impl <- function(x, lag = 1, differences = 1, default = NA) {
  diff_x <- diff(x, lag = lag, differences = differences)
  vec_c(vec_rep(default, lag * differences), diff_x)
}

Refers base function 
Difference for default (numeric) types
base::diff.default
function (x, lag = 1L, differences = 1L, ...) 
{
    ismat <- is.matrix(x)
    xlen <- if (ismat) 
        dim(x)[1L]
    else length(x)
    if (length(lag) != 1L || length(differences) > 1L || lag < 
        1L || differences < 1L) 
        stop("'lag' and 'differences' must be integers >= 1")
    if (lag * differences >= xlen) 
        return(x[0L])
    r <- unclass(x)
    i1 <- -seq_len(lag)
    if (ismat) 
        for (i in seq_len(differences)) r <- r[i1, , drop = FALSE] - 
            r[-nrow(r):-(nrow(r) - lag + 1L), , drop = FALSE]
    else for (i in seq_len(differences)) r <- r[i1] - r[-length(r):-(length(r) - 
        lag + 1L)]
    class(r) <- oldClass(x)
    r
}
Difference for Date type
base::diff.Date
function (x, lag = 1L, differences = 1L, ...) 
{
    ismat <- is.matrix(x)
    xlen <- if (ismat) 
        dim(x)[1L]
    else length(x)
    if (length(lag) != 1L || length(differences) > 1L || lag < 
        1L || differences < 1L) 
        stop("'lag' and 'differences' must be integers >= 1")
    if (lag * differences >= xlen) 
        return(.difftime(numeric(), units = "days"))
    r <- x
    i1 <- -seq_len(lag)
    if (ismat) 
        for (i in seq_len(differences)) r <- r[i1, , drop = FALSE] - 
            r[-nrow(r):-(nrow(r) - lag + 1L), , drop = FALSE]
    else for (i in seq_len(differences)) r <- r[i1] - r[-length(r):-(length(r) - 
        lag + 1L)]
    r
}


ACF / PACF (for data stationarity):

ACF
// Basically takes y and one additional variable from .data to compute the graph
// I would recommend take here, those functions: statsmodels.graphics.tsaplots.plot_acf, statsmodels.graphics.tsaplots.plot_pacf,
// since it is just visualization help before applying ARIMA
function (.data, y, ..., lag_max = NULL, type = c("correlation", 
    "covariance", "partial"), na.action = na.contiguous, demean = TRUE, 
    tapered = FALSE) 
{
    type <- match.arg(type) // get type from 3 choices
    compute_acf <- function(.data, value, lag.max, ...) {
        value <- enexpr(value)
        x <- eval_tidy(value, data = .data)
        acf <- if (tapered) {
            tacf(x)[seq_len(lag_max + 1)]
        }
        else {
            as.numeric(acf(x, plot = FALSE, lag.max = lag.max, 
                ...)$acf)
        }
        if (type != "partial") {
            acf <- tail(acf, -1)
        }
        tibble(lag = seq_along(acf), acf = acf)
    }
    if (dots_n(...) > 0) { // count other variables passed to function, like *args, **kwargs in python 
        lifecycle::deprecate_warn("0.2.2", "PACF(...)", details = "ACF variables should be passed to the `y` argument. If multiple variables are to be used, specify them using `vars(...)`.")
    }
    value <- Filter(negate(quo_is_missing), enquos(y, ...))
    if (length(value) == 0) {
        if (is_empty(measured_vars(.data))) {
            abort("There are no variables to compute the ACF.")
        }
        inform(sprintf("Response variable not specified, automatically selected `var = %s`", 
            measured_vars(.data)[1]))
        value <- syms(measured_vars(.data)[1])
    }
    if (length(value) > 1) {
        warn(sprintf("ACF currently only supports one column, `%s` will be used.", 
            as_name(value[[1]])))
    }
    build_cf(.data, compute_acf, value = !!value[[1]], lag.max = lag_max, 
        demean = demean, type = type, na.action = na.action)
}